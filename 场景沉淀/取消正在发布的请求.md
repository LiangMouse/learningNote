# 取消正在发送的请求

## 场景

为什么要取消发送中，`pending`状态的网络请求，实际上是有很多场景用到的:

- 大文件持续上传时的终止上传按钮
- 连续快速触发请求，如搜索，页面滚动快
- 超时处理，终止请求并提示请求超时

在合适的场景取消掉不该继续的网络请求，会有效优化用户体验以及节省服务器资源

## 实现方法

### 前端

#### **AbortController**

浏览器原生支持的 API, 通常使用这个作为构造函数创建一个`controller`实例, 带有实例方法`AbortController.abort()`支持 中止一个尚未完成的异步操作。这能够中止 fetch 请求及任何响应体和流的使用。

**使用方法**

通常使用时，将该实例带有的`.signal`属性作为 `fetch` 的`options`中的一个属性，然后在需要取消请求的时候调用这个实例上的`abort`方法。

具体可见 [mdn 提供的示例](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController#%E7%A4%BA%E4%BE%8B)

需要注意的一点是在网络请求函数的`catch` 处理时，要注意`if (error.name === 'AbortError')`来处理请求逻辑

**适用范围**

- fetch/axios
- addEventListener （第三个参数 option 来接收）
- 视频流，大文件上传
- React Query
- NodeJS （文件 io, 子进程超时）

虽然蛮多资料都说有浏览器兼容性的问题，但实质上现在适用范围已经相当广

> CancelToken
>
> 早期社区提案中关于取消请求的使用方法，并未真实落地，但是`axios`在一段时间中作为 api 使用，现在新版本`axios`也转向使用`AbortController`

### 服务端

如果单单处理前端的取消请求，实质上对于服务器已经收到请求的情况是于事无补，继续跑逻辑，改数据库。因此要做好，服务端肯定也得配合

**实现方法**

1. 不论是什么服务端语言，前端取消请求后，浏览器会向服务端发送标志位`RST`或`FIN`的 TCP 数据包
2. 语言处理
   1. 异步/协程模型（Go, C#, Modern Java ）启动一个协程/监听器去监控 Socket 状态。一旦断开，框架会关闭 Context 的 Channel 或设置 Token 状态。
   2. 被动触发派 (Java Servlet, PHP, Python WSGI)： 只有当你试图与客户端交互时（读请求体，或写响应体），才会收到操作系统的报错。
3. 在性能损耗高的地方做断点监听处理
4. **绝对不要取消写操作！** 如果客户端断开，要么让它写完，要么利用数据库事务(Transaction)完全回滚。

我们可以发现，服务端支持请求取消是一件成本较高的事情，因此要**慎用取消**

**客户端（前端）：** 取消是**必须的**。为了用户体验（防止 UI 闪烁、竞态问题）和节省用户流量，前端必须积极使用 `AbortController`。

**服务端（后端）：** 取消是**奢侈品**。

- 默认情况下，后端只要感知到连接断开，停止发送响应即可（框架自带功能）。
- 只有在**“该任务极其耗时”**且**“不涉及数据写入一致性”**的前提下，我们才会花费高昂的开发成本去实现“深度中断”。

## 参考资料

[掘金](https://juejin.cn/post/7422285890167160859)
