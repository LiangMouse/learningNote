# 网络请求

直接在函数中或useEffect中调用返回一个网络请求不被推荐，总结来看会有派生状态管理难，竞态处理繁琐，难灵活使用乐观更新，处理缓存不易，请求合并去重等等问题，下边一一详细道来

## 乐观更新

**含义**: 对于有些更新往往需要请求正常收到响应后才能生效，但是为了用户体验的流畅，可以选择先使改动生效，然后根据请求状态确定是否继续生效

这里可能比较有趣的例子是当我们在社媒上发送辱骂或者鉴证的评论时，往往会出现看到发出去但实际别人看不到的情况，这就是乐观更新发力了。
实际上乐观更新的应用场景有很多，毕竟你也不想看到点个东西没反应要过几秒才生效，或者处处都是加载中😵‍💫

## 竞态问题

**含义**: 请求的发起顺序和响应顺序不一定相同，比如说一个竞态处理糟糕的搜索框，当你迅速输入前列腺时，搜索框显示你默认推荐可能还是第一个字出来的前端面试。

**常见场景**: 搜索筛选分页等请求响应处理频繁的场景，用户处理越快开发的处理越不得当，就越容易出现错位的情况，或者说用户的操作频率大于网络的响应速度，渲染结果就会与预期相差甚远

**处理方式**:

- 信号量处理初次请求

    闭包捕获上层作用域清理回调时，第二个请求发过来的时候调用第一个的清理函数使得最终收到的`response`一定是最新的那个
    如以下代码是[React官网](https://zh-hans.react.dev/reference/react/useEffect#fetching-data-with-effects) 使用useEffect处理网络请求的demo
    ```jsx
    import { useState, useEffect } from 'react';
    import { fetchBio } from './api.js';

    export default function Page() {
    const [person, setPerson] = useState('Alice');
    const [bio, setBio] = useState(null);

    useEffect(() => {
        let ignore = false;
        setBio(null);
        fetchBio(person).then(result => {
        if (!ignore) {
            setBio(result);
        }
        });
        return () => {
        ignore = true;
        };
    }, [person]);
    }
    ```
- `AbortController` API
浏览器API，可以从网络层面终止请求。包含一个signal属性，可传递给fetch等支持取消的 API。调用controller.abort()时，会触发signal的abort事件，从而终止关联的操作

```jsx
  useEffect(() => {
    // 创建AbortController实例
    const controller = new AbortController();
    // 获取用于取消请求的signal
    const { signal } = controller;

    setBio(null);
    
    // 调用API时传入signal
    fetchBio(person, { signal })
      .then(result => {
        setBio(result);
      })
      .catch(error => {
        // 过滤主动取消的错误，避免控制台报错
        if (error.name !== 'AbortError') {
          console.error('请求失败:', error);
        }
      });

    // 清理函数：组件卸载或person变化时取消请求
    return () => {
      controller.abort(); // 主动取消当前请求
    };
  }, [person]);
```

## 缓存问题

场景: 从列表页跳转到详情页的软链接跳转需要合理的添加缓存，避免多次重复请求，多次loading，影响用户体验
**处理方式**
- Vue中的keep-alive组件
- 变量提升，比如用户信息数据存到全局状态管理库，缓存时间久的数据存到父组件作为prop传到子组件
- 即使在数据时效性要求高的场景下，也可以先展示缓存，静默发起请求，作diff然后判断是否重新渲染
- Map存储缓存数据，并自定义更新缓存逻辑



## useEffect为什么不推荐作请求

[详情看官网](https://zh-hans.react.dev/reference/react/useEffect#what-are-good-alternatives-to-data-fetching-in-effects)

推荐的解决方案有 `React Query`、`useSWR`、`ahooks`等
