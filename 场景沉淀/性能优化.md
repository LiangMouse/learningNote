# 性能优化

## 指标

Core Web Vitals

- LCP(Largest Contentful Paint) - 最大内容绘制 加载性能
- INP(Interaction to Next Paint) - 下次绘制的交互 衡量交互响应性
- CLS(Cumulative Layout Shift) - 累计布局便宜 量化页面在加载过程中，可见元素发生非预期位移的程度总和
- FCP(First Contentful Paint) - 首次内容绘制 浏览器渲染出第一个 DOM 内容的时间点
- TTI (Time to Interactive) - 可交互时间，页面渲染完成且主线程完全空闲能够快速可靠响应用户输入的时间点
- TTFB (Time to First Byte) - 首字节时间，浏览器接收服务器响应第一个字节所经历的时间

| **指标** | **英文全称**              | **衡量方面** | 何意味                                                                                   |
| -------- | ------------------------- | ------------ | ---------------------------------------------------------------------------------------- |
| **LCP**  | Largest Contentful Paint  | **加载速度** | 视口最大图像或文本块完成渲染的时间点                                                     |
| **INP**  | Interaction to Next Paint | **交互响应** | 从交互开始到浏览器渲染用户收到反馈所花费的时间                                           |
| **CLS**  | Cumulative Layout Shift   | **视觉稳定** | 量化页面在加载过程中，可见元素发生非预期位移的量化数据                                   |
| FCP      | First Contentful Paint    | 感知速度     | 浏览器渲染出第一个 DOM 内容的时间点                                                      |
| TTFB     | Time to First Byte        | 服务器响应   | 首字节时间，浏览器接收服务器响应第一个字节所经历的时间                                   |
| TBT      | Total Blocking Time       | 主线程阻塞   | FCP 和 TTI 之间，主线程被“长任务”（Long Task，执行时间超过 50 毫秒的任务）所阻塞的总时间 |

## 性能优化方式

### 加载时性能

可以按照浏览器加载页面的完整流程，梳理常见的优化手段：

1. DNS 解析 & 网络链接

   每次 TCP、TLS 等握手以及 DNS 查找都需要额外的 RTT，容易阻塞整体加载性能。

   - DNS 预解析
     - **方式**: 在 HTML 的 `<head>` 中使用 `<link rel="dns-prefetch" href="//example.com">`。
     - **作用：** 提前解析未来可能用到的（尤其是第三方）域名，减少后续请求时的 DNS 查询延迟。
   - 预连接（Preconnect）
     - **方法:** `<link rel="preconnect" href="//example.com">`
     - **作用:** 比 `dns-prefetch` 更进一步，不仅解析 DNS，还会提前建立 TCP 和 TLS 连接，适合用于已确定即将请求的关键资源（如 CDN、API 服务）。
   - 开启 HTTP2 / 3
     - **方法：**通常由服务器和上层网关开启
     - **作用:** HTTP2 多路复用，头部压缩，数据帧，HTTP3 引入 QUIC 彻底解决队头阻塞，QUIC 整合 TLS 与传输层握手，减少 RTT 耗时

2. 服务器响应

   连接建立后，浏览器发送 HTTP 请求，服务端处理请求直到浏览器收到响应的时间，会受到网络链路 RTT 和服务器处理能力的共同制约。

   - 使用 CDN
     - **方式**: 前端资源部署时所使用云服务时开启，如 cloudflare、阿里云等
     - **作用**： 降低单位 RTT 耗时（物理距离减少，光纤传输耗时降低）
   - 优化后端处理
     - **方式：** 多种多样，这里侧重前端性能优化不展开，例如数据库索引、Redis 缓存等。
     - **作用:** 降低服务端处理耗时。

3. HTML 等静态资源下载与解析

   浏览器收到资源后到完成解析的过程中，既涉及下载也涉及解析，在此阶段同样可以着手性能优化。

   - 服务器发送 HTML 等静态资源前进行压缩
     - **方式:** 在部署服务器时开启 gzip 等动态压缩，将压缩后的数据流发送给浏览器。
   - SSR 服务端渲染，首屏速度比传统 CSR 快得多
   - 精简构建产物(具体在构建工具中讲)
     - 代码分割 (Code Splitting) 、 组件懒加载、依赖(node_modules)单独做成`verdor chunk`
     - 在构建工具中开启 Tree Shaking。
     - 代码压缩，如删除空行注释换行，变量名变短等
     - CSS 抽成单独的.css，实现与 JS 的并行下载解析
     - 优化静态资源，例如将图片由 PNG/JPEG 转成更小的 WebP，字体使用压缩率更高的 WOFF2，图片标签搭配 `loading="lazy"`。
   - 开启缓存

4. 关键资源加载

   CSS 和 JS 是渲染链路中的“阻塞器”。

   - 将关键 CSS 提取后内联到 `<head>` 标签的 `<style>` 中，浏览器无需额外请求即可开始渲染，降低 FCP。
   - 异步加载非关键 CSS
   - `script`标签使用`defer`和`async`

### 运行时性能

关注页面加载完成后，用户交互阶段的性能表现。

- 虚拟列表等方式优化长列表、大量 DOM 的渲染场景。
- 防抖、节流降低高频事件的触发频率。
- 事件委托减少事件绑定数量。
- `Web Worker` 开启后台线程处理复杂计算，提升并发能力。
- `WASM` 在主线程运行 `C++` 或 `Rust`，执行速度明显快于 JS。
- 尽量减少不必要的重绘与重排。
- 使用 `requestAnimationFrame` 协调动画时序。
