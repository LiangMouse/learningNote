# 大数据渲染

在前端开发中，当需要渲染大量数据时（如数万条记录），直接渲染会导致页面卡顿、内存占用过高等性能问题。常见的解决方案主要分为**分片渲染**和**虚拟列表**两种。

## 分片渲染（Time Slicing）

### 核心思想

分片渲染是将大量数据分批次渲染的技术，其核心思想是：
- 将大任务拆分成多个小任务
- 利用浏览器的空闲时间进行渲染
- 避免长时间阻塞主线程，保持页面响应性

### 实现方式

#### 1. 定时器实现（setTimeout）

```javascript
function renderLargeList(data, container, batchSize = 100) {
  let index = 0;

  function renderBatch() {
    const fragment = document.createDocumentFragment();
    const end = Math.min(index + batchSize, data.length);

    for (let i = index; i < end; i++) {
      const item = document.createElement('div');
      item.textContent = data[i];
      fragment.appendChild(item);
    }

    container.appendChild(fragment);
    index = end;

    if (index < data.length) {
      setTimeout(renderBatch, 0); // 让出控制权给浏览器
    }
  }

  renderBatch();
}
```

#### 2. requestIdleCallback 实现（推荐）

其中React的`fiber`就是基于requestIdleCallback相似的思想实现的
```javascript
function renderLargeListWithIdle(data, container, batchSize = 100) {
  let index = 0;

  function renderBatch(deadline) {
    while (deadline.timeRemaining() > 0 && index < data.length) {
      const fragment = document.createDocumentFragment();
      const end = Math.min(index + batchSize, data.length);

      for (let i = index; i < end; i++) {
        const item = document.createElement('div');
        item.textContent = data[i];
        fragment.appendChild(item);
      }

      container.appendChild(fragment);
      index = end;
    }

    if (index < data.length) {
      requestIdleCallback(renderBatch);
    }
  }

  requestIdleCallback(renderBatch);
}
```

#### 3. React 中的分片渲染

```jsx
import { useState, useEffect } from 'react';

function ChunkedList({ data, chunkSize = 100 }) {
  const [displayedItems, setDisplayedItems] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    if (currentIndex < data.length) {
      const timer = setTimeout(() => {
        const nextChunk = data.slice(currentIndex, currentIndex + chunkSize);
        setDisplayedItems(prev => [...prev, ...nextChunk]);
        setCurrentIndex(prev => prev + chunkSize);
      }, 0);

      return () => clearTimeout(timer);
    }
  }, [currentIndex, data, chunkSize]);

  return (
    <div>
      {displayedItems.map((item, index) => (
        <div key={index}>{item}</div>
      ))}
    </div>
  );
}
```

### 优缺点

**优点：**
- 实现简单，易于理解
- 保持页面响应性
- 适用于各种场景

**缺点：**
- 仍会渲染所有数据，内存占用较高
- 滚动性能可能受影响
- 不适合超大数据集

## 虚拟列表（Virtual List）

### 核心思想

虚拟列表只渲染可视区域内的元素，通过动态计算和更新可见项来实现高性能渲染。

### 基本实现

```javascript
class VirtualList {
  constructor(container, data, itemHeight, visibleCount) {
    this.container = container;
    this.data = data;
    this.itemHeight = itemHeight;
    this.visibleCount = visibleCount;
    this.startIndex = 0;

    this.init();
  }

  init() {
    // 创建容器
    this.listContainer = document.createElement('div');
    this.listContainer.style.height = `${this.data.length * this.itemHeight}px`;
    this.listContainer.style.position = 'relative';

    // 创建可视区域
    this.visibleContainer = document.createElement('div');
    this.visibleContainer.style.height = `${this.visibleCount * this.itemHeight}px`;
    this.visibleContainer.style.overflow = 'auto';

    this.container.appendChild(this.visibleContainer);
    this.visibleContainer.appendChild(this.listContainer);

    // 绑定滚动事件
    this.visibleContainer.addEventListener('scroll', this.handleScroll.bind(this));

    this.render();
  }

  handleScroll() {
    const scrollTop = this.visibleContainer.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    this.render();
  }

  render() {
    const endIndex = Math.min(this.startIndex + this.visibleCount, this.data.length);
    const fragment = document.createDocumentFragment();

    // 清空现有内容
    this.listContainer.innerHTML = '';

    for (let i = this.startIndex; i < endIndex; i++) {
      const item = document.createElement('div');
      item.style.position = 'absolute';
      item.style.top = `${i * this.itemHeight}px`;
      item.style.height = `${this.itemHeight}px`;
      item.textContent = this.data[i];
      fragment.appendChild(item);
    }

    this.listContainer.appendChild(fragment);
  }
}
```

### React 虚拟列表实现

```jsx
import { useState, useEffect, useRef } from 'react';

function VirtualList({ data, itemHeight = 50, containerHeight = 400 }) {
  const [startIndex, setStartIndex] = useState(0);
  const containerRef = useRef();

  const visibleCount = Math.ceil(containerHeight / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount + 1, data.length);
  const totalHeight = data.length * itemHeight;
  const offsetY = startIndex * itemHeight;

  const handleScroll = (e) => {
    const scrollTop = e.target.scrollTop;
    const newStartIndex = Math.floor(scrollTop / itemHeight);
    setStartIndex(newStartIndex);
  };

  return (
    <div
      ref={containerRef}
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        {data.slice(startIndex, endIndex).map((item, index) => (
          <div
            key={startIndex + index}
            style={{
              position: 'absolute',
              top: offsetY + index * itemHeight,
              height: itemHeight,
              width: '100%',
            }}
          >
            {item}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 优缺点

**优点：**
- 内存占用低，只渲染可见元素
- 滚动性能优秀
- 适合超大数据集

**缺点：**
- 实现复杂度较高
- 需要固定或可预测的项目高度
- 搜索和定位功能实现困难

## 性能优化建议

### 1. 选择合适的方案

- **数据量 < 1000**：直接渲染
- **1000 < 数据量 < 10000**：分片渲染
- **数据量 > 10000**：虚拟列表

### 2. 通用优化技巧

```javascript
// 使用 DocumentFragment 减少重排
const fragment = document.createDocumentFragment();

// 批量更新样式
element.style.cssText = 'height: 50px; width: 100px;';

// 使用 transform 代替改变 top/left
element.style.transform = `translateY(${offset}px)`;

// 防抖滚动事件
const debouncedScroll = debounce(handleScroll, 16);
```

### 3. 内存管理

```javascript
// 及时清理不需要的 DOM 节点
function cleanupNodes(container) {
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }
}

// 使用对象池复用 DOM 元素
class NodePool {
  constructor(createElement) {
    this.pool = [];
    this.createElement = createElement;
  }

  get() {
    return this.pool.pop() || this.createElement();
  }

  release(node) {
    this.pool.push(node);
  }
}
```

## 实际应用场景

1. **表格组件**：大量数据的表格展示
2. **聊天记录**：历史消息的滚动加载
3. **商品列表**：电商平台的商品展示
4. **日志查看器**：开发工具中的日志展示
5. **数据可视化**：大量数据点的图表渲染

## 总结

大数据渲染的核心是在用户体验和性能之间找到平衡点。分片渲染适合中等规模的数据，实现简单；虚拟列表适合大规模数据，性能优秀但实现复杂。在实际项目中，应根据具体需求选择合适的方案，并结合其他性能优化技巧来提升整体体验。
