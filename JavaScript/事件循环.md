# 事件循环

JavaScript 语言设计之初为处理 DOM，防止不同节点的线程冲突因此设计为单线程语言（HTML5 的 Web Worker 标准，允许在主线程之外 JavaScript 脚本创建多个线程运行）

事件循环就是在特定 JS 运行时下解决异步代码执行提供的机制，浏览器事件循环由 `HTML` 规范定义，而 Node 的事件循环由 `libuv` 机制决定，下边分开来讲

## 浏览器 V8 事件循环

### 机制

同步任务都在主线程执行，形成一个执行栈，原地放入立即执行
异步函数先放入宿主环境（可以多线程执行）
JS 的异步是通过回调函数实现，当在宿主环境中时间好了，就把异步函数的回调函数添加到任务队列(也称为消息队列)中
当执行栈清空完后会看任务队列中有无回调函数，如果有会被添加到执行栈中执行
JS 先执行执行栈的同步任务，再异步任务放入任务队列中，一旦执行栈中所有同步任务执行完毕，系统依次读取任务队列同步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
为什么称之为执行栈而不是执行队列？
执行栈中同步函数入栈后立即执行然后出栈，同时如果函数内部有其他函数调用情况，就会出现后进先出，根本上是一个队列

### 宏任务与微任务

在 23 年 6 月 [WHATWG HTML Living Standard](link.wtturl.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loops&scene=im&aid=497858&lang=zh)之前，任务队列仅分为宏任务队列和微任务队列。
JavaScript 执行完同步函数后会先执行微任务，微任务队列全部清空后再执行宏任务，宏任务执行一次便再执行全部的微任务，周而复始

**宏任务（Macrotask**

在旧规范的社区共识（及早期 HTML 标准隐含逻辑）中，“宏任务” 的**定义**是：由浏览器发起、需要排队执行的 “独立任务单元”，而整个 script 标签的代码，是浏览器加载 HTML 后发起的第一个宏任务（可称为 “根宏任务”）。宏任务有：

- script (可以理解为外层同步代码)
- setTimeout/setInterval
- UI rendering/UI 事件/ 用户交互事件
- fetch 等网络 IO
- postMessage、MessageChannel

宏任务不是 “异步代码” 的代名词，而是一个 “任务容器”—— 同步代码是这个容器里的 “执行内容”，异步任务是执行过程中 “新增的待办”

**微任务（Microtask**

更小的任务单元，在执行完当前宏任务后立即执行，比如：

- Promise 的回调函数（then 和 catch...）
- MutationObserver
- queueMicrotask()
- async 中的 await 函数
- process.nextTick

#### 总结前过程

1. **执行当前宏任务**
   1. - 宏任务是由浏览器发起的“独立任务单元”，例如： - 整个 `<script>` 标签的代码（根宏任务）；
   2. - `setTimeout`、`setInterval` 的回调；
   3. - DOM 事件回调（如点击、滚动）。
   4. - **同步代码属于宏任务的核心执行内容**：直接写在宏任务中的 `console.log`、函数调用等同步代码，会在宏任务执行时按顺序执行。
2. **在执行宏任务过程中动态添加新任务**
   1. - 遇到 `setTimeout` 等宏任务时，将其回调添加到宏任务队列；
   2. - 遇到 `Promise.then` 等微任务时，将其回调添加到微任务队列。
3. **当前宏任务执行完毕（同步代码执行完）** - 执行栈自动清空（无需手动操作），因为同步代码执行完毕后，执行栈中的函数上下文会按后进先出顺序依次弹出。
4. **强制清空微任务队列**
   1. - 必须执行微任务队列中的所有回调，包括在微任务执行过程中新增的微任务。
   2. - 微任务的优先级高于渲染，确保高优先级逻辑（如 `Promise` 链式调用）在渲染前完成。
5. **浏览器可选执行渲染** - 规范未强制要求渲染，但实际浏览器会在此阶段更新 UI（如重绘、回流）。 - 渲染可能被浏览器优化，例如合并多次更新以提高帧率。
6. **返回步骤 1，循环处理下一个宏任务** - 从宏任务队列中取出最旧的任务，重复上述流程。

### 现在的任务队列与事件循环

新版模型（2023 年 6 月后）

规范里不再说“单个宏任务队列”，而是任务源（task source）对应不同的车道（task queues），并且规定了调度优先级。

- 🚦 交互车道 (user interaction task source)
  处理 click、keydown、input、scroll 等用户输入事件。优先级最高，保证用户操作能尽快响应。

- ⏳ 延时车道 (timer task source)
  setTimeout / setInterval。

- 🌐 I/O 车道 (networking task source)
  fetch、XHR、WebSocket 等。

- 🎨 渲染车道 (rendering task source)
  布局、样式、绘制任务。

- 🛑 空闲车道 (idle task source)
  requestIdleCallback 等。

事件循环每次循环不再是“盲取宏任务队列”，而是按 **优先级策略**调度不同的车道。这样保证了用户交互不会被长时间的 timer/I/O 堵塞，提高了交互实时性。简单理解就是宏任务队列上又增加了优先级

## Node 事件循环

Node 的事件循环由 `libuv` 决定，再加上 Node 特有的 `process.nextTick / setImmediate`。libuv：Node 的底层库，负责 I/O、多线程、定时器等，它实现了 Node 的事件循环。

它和浏览器的主要区别：

- 浏览器只有宏任务 + 微任务。
- Node.js 拆成 6 个阶段，微任务夹在阶段之间跑。

### 六个阶段（宏任务阶段）

想象 Node 是个工厂，每一轮生产（一个事件循环 tick）都分成 6 道工序，每道工序负责不同类型的任务：

`timers → pending callbacks → idle, prepare → poll → check → close callbacks`

1. **timers**
   专门执行 setTimeout 和 setInterval 到期的回调。
2. **pending callbacks**
   一些系统级别的延迟回调，比如 TCP 错误、网络请求的某些残留任务。平时写代码几乎遇不到，算是内部清理用。

3. **idle, prepare**
   内部用的阶段，不用关心。就像工厂工人休息和准备的环节。

4. **poll**
   最重要的阶段！检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。比如网络请求、数据库查询、文件读写

5. **check**
   专门执行 `setImmediate` 的回调。这是 Node.js 独有的 API，你可以理解为“立即在本轮循环的尾部跑”。

6. **close callbacks**
   一些关闭事件的回调，比如 socket.on('close', ...)。

除了上述 6 个阶段，还存在 process.nextTick 及其他微任务，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队

### 易于做题和记忆的总结

```css
[阶段宏任务执行开始]
  ↓
  执行宏任务（回调）
      ↓
      清空 nextTick 队列
      清空 Promise/queueMicrotask 队列
  ↓
[阶段宏任务执行下一个回调]
```

1. next tick microtask queue
2. other microtask queue
3. timer queue
4. poll queue
5. check queue
6. close queue

---

> 参考资料
>
> - [图形化模拟事件循环过程](https://www.jsv9000.app/)
> - https://github.com/febobo/web-interview/issues/73
> - https://vue3js.cn/interview/NodeJS/event_loop.html#%E4%B8%89%E3%80%81%E9%A2%98%E7%9B%AE
