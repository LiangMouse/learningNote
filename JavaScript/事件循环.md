# 事件循环

面试题常给段代码分析执行顺序，而且开发中也会实际遇到这类问题
推荐一个 <a href="https://www.jsv9000.app/">网站</a>，可以即时调试查看事件循环过程

## 单线程

浏览器的 JS 解析器执行特点是单线程，意味着同一时间只能执行一个任务

浏览器两个引擎，渲染引擎，解析 HTML 和 CSS
JS 解析器，运行在浏览器的主线程
谷歌的 V8 引擎解析 JS
JS 解析机制
JS 运行特点之一是单线程(同 一时间只能做一件事)，意味着前一个任务结束，才能执行后一个任务，但是浏览器的其他线程可以同时工作来处理异步执行任务
为了更好运用多核 CPU 计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程
Web worker 是独立线程，在此之前就有不阻塞主线程执行的异步操作。webserver 是在此之外引入的机制，允许在多个独立的线程中运行 JavaScript，从而更高效利用多核 CPU 进行并发处理
异步 做一个事需要花费一段时间，在做的同时可以去处理其他内容
同步任务都在主线程执行，形成一个执行栈，原地放入立即执行
异步函数先放入宿主环境（可以多线程执行）
JS 的异步是通过回调函数实现，当在宿主环境中时间好了，就把异步函数的回调函数添加到任务队列(也称为消息队列)中
当执行栈清空完后会看任务队列中有无回调函数，如果有会被添加到执行栈中执行
JS 先执行执行栈的同步任务，再异步任务放入任务队列中，一旦执行栈中所有同步任务执行完毕，系统依次读取任务队列同步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
为什么称之为执行栈而不是执行队列？
执行栈中同步函数入栈后立即执行然后出栈，同时如果函数内部有其他函数调用情况，就会出现后进先出，根本上是一个队列

宏任务与微任务
在任务队列中，从更细颗粒度角度划分，还有宏任务队列和微任务队列
JavaScript 执行完同步函数后会先执行微任务，微任务队列全部清空后再执行宏任务，宏任务执行一次便再执行全部的微任务，周而复始
● 宏任务（Macrotask）：每次事件循环的主任务，包含了一些较大的任务单元，比如：
● setTimeout(同步执行完才开始计时)
● setInterval
● I/O 操作
● DOM 事件回调
● 微任务（Microtask）：更小的任务单元，在执行完当前宏任务后立即执行，比如：
● Promise 的回调函数（then() 和 catch()）
● MutationObserver
● queueMicrotask()
console.log('Start');

setTimeout(function() {
console.log('Macrotask');
}, 0);

Promise.resolve().then(function() {
console.log('Microtask 1');
}).then(function() {
console.log('Microtask 2');
});

console.log('End');
注:promise 本身属于同步函数，.then 和.catch 异步，所以 promise 内不涉及异步的仍是放入执行栈中
打印输出结果题可以使用画执行栈，宏任务队列，微任务队列的方式看判断顺序
练习事件循环 jsv9000.app
