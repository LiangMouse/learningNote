# 事件循环

面试题常给段代码分析执行顺序，而且开发中也会实际遇到这类问题
推荐一个 <a href="https://www.jsv9000.app/">网站</a>，可以即时调试查看事件循环过程

## 单线程

JavaScript 语言设计之初为处理 DOM，防止不同节点的线程冲突因此设计为单线程语言

HTML5 的 Web Worker 标准，允许在主线程之外 JavaScript 脚本创建多个线程运行 JavaScript，从而更高效利用多核 CPU 进行并发处理异步请求，事件循环是为处理单线程的异步任务而生的

##

同步任务都在主线程执行，形成一个执行栈，原地放入立即执行
异步函数先放入宿主环境（可以多线程执行）
JS 的异步是通过回调函数实现，当在宿主环境中时间好了，就把异步函数的回调函数添加到任务队列(也称为消息队列)中
当执行栈清空完后会看任务队列中有无回调函数，如果有会被添加到执行栈中执行
JS 先执行执行栈的同步任务，再异步任务放入任务队列中，一旦执行栈中所有同步任务执行完毕，系统依次读取任务队列同步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
为什么称之为执行栈而不是执行队列？
执行栈中同步函数入栈后立即执行然后出栈，同时如果函数内部有其他函数调用情况，就会出现后进先出，根本上是一个队列
宏任务与微任务
在任务队列中，从更细颗粒度角度划分，还有宏任务队列和微任务队列
JavaScript 执行完同步函数后会先执行微任务，微任务队列全部清空后再执行宏任务，宏任务执行一次便再执行全部的微任务，周而复始
● 宏任务（Macrotask）：每次事件循环的主任务，包含了一些较大的任务单元，比如：
● setTimeout(同步执行完才开始计时)
● setInterval
● I/O 操作
● DOM 事件回调
● 微任务（Microtask）：更小的任务单元，在执行完当前宏任务后立即执行，比如：
● Promise 的回调函数（then() 和 catch()）
● MutationObserver
● queueMicrotask()
console.log('Start');

setTimeout(function() {
console.log('Macrotask');
}, 0);

Promise.resolve().then(function() {
console.log('Microtask 1');
}).then(function() {
console.log('Microtask 2');
});

console.log('End');
注:promise 本身属于同步函数，.then 和.catch 异步，所以 promise 内不涉及异步的仍是放入执行栈中
打印输出结果题可以使用画执行栈，宏任务队列，微任务队列的方式看判断顺序
