# JS 模块化

## 为什么需要模块化

JavaScript 脱离浏览器、走向服务端（Node.js）后，工程规模迅速扩大，随之而来的是依赖管理、命名冲突、可维护性与可复用性等问题。模块化为此提供了标准化的组织与加载机制。

## 发展脉络（概览）

- CommonJS：社区提出，首先在 Node.js 落地，用于服务端。
- AMD/CMD：面向浏览器的社区规范，用于异步加载脚本。
- ES Modules（ESM）：ES2015 起的官方模块方案，浏览器与服务端均可用。

## CommonJS

- 一个文件就是一个模块。
- 通过 `require(path)` 引入模块（同步加载，适合本地磁盘）。
- 通过 `module.exports` 或 `exports` 导出成员（以对象为出口）。
- 首次加载会进行执行与缓存，后续 `require` 直接返回缓存结果（单例特性）。

为何不直接用于浏览器？

- CommonJS 设计为同步加载，而浏览器通常通过网络获取脚本，必须以异步方式加载，故浏览器端转向 AMD/CMD/ESM。

## 规范对比（简表）

| 规范     | 运行环境      | 加载方式 | 运行机制 | 主要特点                     |
| -------- | ------------- | -------- | -------- | ---------------------------- |
| CommonJS | 服务器        | 同步     | 运行时   | 缓存首次执行结果，后续走缓存 |
| AMD      | 浏览器        | 异步     | 运行时   | 依赖前置，通常全量加载       |
| CMD      | 浏览器        | 异步     | 运行时   | 依赖就近，按需延迟           |
| ESM      | 浏览器/服务端 | 异步     | 编译时   | 静态依赖分析，便于优化       |

## 进一步阅读（工程化落地）

- 如何在构建工具中选择产物格式、落地按需加载与 Tree Shaking，请见：[前端工程化中的模块化内容](../Engineering/JS模块化方案.md)
