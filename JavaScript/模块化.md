# JS 模块化

Node.js 的诞生意味着 JavaScript 可以在服务端运行。脱离了浏览器宿主环境的限制，JS 可以干更多事情，也更加的像是一门真正的语言了。但是，如果想要做大、做强，那么一定要有一个很好的**模块化解决方案**。经过社区激烈的讨论之后，`CommonJS` 诞生了。随后，CommonJS 在 Node.js 中得到应用，为前端接来下的迅猛发展奠定了基础。

随后又推出了在浏览器环境下使用的模块化规范 AMD。紧接着又推出了对 AMD 规范改进的 CMD 规范。但是 CommonJS、AMD、CMD 都只是来自于社区的模块化规范，直到 ES2015，才有官方的模块化解决方案：`ES Modules`。

CommonJS 是随着 JS 在服务端的发展而发展起来的，Node.js 中的模块系统就是参照 CommonJS 规范实现的。

CommonJS 规范的具体内容如下：

- 一个文件就是一个模块；
- module 对象代表模块自身，module 中有两个属性，require 和 export；
- 使用 `require(path)` 方法引入外模模块，其中 path 可以是相对路径也可以是绝对路径；
- 使用 `export` 对象作为唯一出口导出模块。

CommonJS 不能直接移植进浏览器使用。本质因为其服务于服务端，设计思想是同步加载模块，制约不过是读取硬盘时间。而浏览器加载模块需要将模块通过网络下载到本地，因此受限于性能只能异步加载模块，浏览器端只能转向其他模块化规范

|          | 运行环境      | 加载方式 | 运行机制 | 特点                                                   |
| -------- | ------------- | -------- | -------- | ------------------------------------------------------ |
| CommonJS | 服务器        | 同步     | 运行时   | 第一次加载后会将结果缓存，再次加载会读取缓存的结构。   |
| AMD      | 浏览器        | 异步     | 运行时   | 依赖前置，不管模块是否有用到，都会全量加载。           |
| CMD      | 浏览器        | 异步     | 运行时   | 依赖就近，延迟加载                                     |
| ESM      | 浏览器/服务端 | 异步     | 编译时   | 静态化，在编译时就确定模块之间的依赖关系，输入和输出。 |

## 核心要点速览

- 规范与运行时：`CommonJS` 强运行时、同步；`ESM` 强编译时、静态依赖。
- 产物格式：`cjs`、`esm`、`umd`、`iife` 面向不同运行环境与加载场景。
- 互操作性：Node.js 支持 `type: module` 与双入口（`exports` 字段区分 `import`/`require`）。
- Tree Shaking：依赖静态分析（ESM 更友好），结合 `sideEffects` 标注更稳妥。
- 动态加载：浏览器/打包器侧通过 `import()` 支持按需加载与代码分割。

## 进一步阅读（工程化落地）

- 工具与配置如何落地模块化、如何选择产物格式、如何做按需加载与 Tree Shaking，请见：`Engineering/JS模块化方案.md`
