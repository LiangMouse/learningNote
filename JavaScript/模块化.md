# JS 模块化

## 为什么需要模块化

JavaScript 脱离浏览器、走向服务端（Node.js）后，工程规模迅速扩大，随之而来的是依赖管理、命名冲突、可维护性与可复用性等问题。模块化为此提供了标准化的组织与加载机制。

最显然的是，如果没有模块化，两个不同文件声明的充名全局变量就会起冲突。

## 发展脉络（概览）

- IIFE: 利用了 JavaScript “只有函数才有作用域” 的特性，造出了一个“人工的模块环境”。
- CommonJS：社区提出，首先在 Node.js 落地，用于服务端。
- AMD/CMD：面向浏览器的社区规范，用于异步加载脚本。
- ES Modules（ESM）：ES2015 起的官方模块方案，浏览器与服务端均可用。

## 模块化方案

### CommonJS

- 一个文件就是一个模块。
- 通过 `require(path)` 引入模块（同步加载，适合本地磁盘）。
- 通过 `module.exports` 或 `exports` 导出成员（以对象为出口）。
- 首次加载会进行执行与缓存，后续 `require` 直接返回缓存结果（单例特性）。
- 支持条件引入，也就是不必文件头部`require`，支持在条件语句中`require`

主要用于 Node 等服务端

- CommonJS 设计为同步加载，而浏览器通常通过网络获取脚本，必须以异步方式加载，故浏览器端转向 AMD/CMD/ESM。

**简要原理**
`CommonJS`处理模块化的变量隔离其实与`IIFE`一脉相承。

```javascript
// 你写的代码：
// var a = 1;

// Node.js 实际执行的：
(function (exports, require, module, __filename, __dirname) {
  var a = 1; // 变成了局部变量，不会污染全局！
});
```

### ESM

- 不同于`CJS`的运行时加载，使用 `ESM` 的项目会在打包前构建依赖关系图，也就是编译时。这个 `ESM` 的特性支持前端构建工具如`vite`进行树摇操作
- 支持异步引入，不仅仅是顶层直接引入，支持`await import()`作异步懒加载
- 支持具名导出和默认导出两种方式。`CJS`只支持导出那个`exports`对象
- 导出的变量值是作为 **“指针”** 传递，传递引用，而`CJS`是传递值的拷贝

**使用方式**

- NodeJS 环境中将`package.json`的`type`字段设置为`module`，或者用`.mjs`作为后缀文件拓展名
- 浏览器原生支持 ESM 作为模块化方案

## 规范对比（简表）

| 规范     | 运行环境      | 加载方式 | 运行机制 | 主要特点                     |
| -------- | ------------- | -------- | -------- | ---------------------------- |
| CommonJS | 服务器        | 同步     | 运行时   | 缓存首次执行结果，后续走缓存 |
| AMD      | 浏览器        | 异步     | 运行时   | 依赖前置，通常全量加载       |
| CMD      | 浏览器        | 异步     | 运行时   | 依赖就近，按需延迟           |
| ESM      | 浏览器/服务端 | 异步     | 编译时   | 静态依赖分析，便于优化       |

尽管在 Node 中会遇到兼容性的问题，但是`ESM`无疑是现在最受欢迎也是未来更流行的模块化方案

## 进一步阅读（工程化落地）

- 如何在构建工具中选择产物格式、落地按需加载与 Tree Shaking，请见：[前端工程化中的模块化内容](../Engineering/JS模块化方案.md)

## 参考资料

- [ESM 还是 Commonjs](https://blog.logrocket.com/commonjs-vs-es-modules-node-js/)
