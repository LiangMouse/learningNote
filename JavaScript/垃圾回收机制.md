# JS 垃圾回收机制

## 基本释义

GC 也就是 `Garbage Collection`，对程序内存中不再使用或者未使用的内存，也就是垃圾进行清理回收的过程称为垃圾回收机制。除 C++ 外的各 JS 引擎对于垃圾回收机制的实现不同，下边具体以 V8 引擎作为示例。

> 程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。

## 垃圾回收策略

**可达性**：JS 数据能够被某种路径访问到或者被使用即成为可达，JS 引擎需要保证可达数据的存储，反之则需要做清理。

这也就引到了垃圾回收引擎核心的工作，定期找到不需要的数据所在内存进行清除，重点就在于如何找到，如何释放清除。

其中，标记清除算法和引用计数算法是两种最常用的实现算法。

### 标记清除算法

顾名思义，这个算法对所有数据来讲分为两个阶段，标记和清除。标记阶段给所有活动的活动性对象加上标记，清除阶段把代表不可达标记的数据进行清除。是现在浏览器中最常用的垃圾回收算法。

**算法流程**

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收

**优点**

标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0 和 1）就可以为其标记，非常简单。

**缺点**

标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 **内存碎片**。再去堆中为对象分配内存时就会面临对空闲内存列表进行寻找切片进行动态分配的最佳适应，最先适应等算法，然后会越来越碎片。

#### 标记整理算法

为解决上述提到的缺点，设计了标记整理算法。简单说就是在标记清楚算法的基础上，把不需要清除的内存往堆的一端移动，保证可用内存的连续性。

### 引用计数算法

引用计数算法把对象是否不再需要抽象成当前对象是否还有其他对象引用到他，如果零引用，则会把他清理掉。是一个比较早期的 GC 算法。

**策略**

他的策略是跟踪记录每个变量的被使用次数，比如赋值时加一，被赋值覆盖时减一，如果变为 0 则回收空间。

```javascript
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```

**优点**

不同于标记清除是定时标记定时清除，引用计数算法可以做到立即回收垃圾。

**缺点**

1. 需要创建一个计数器属性存放属性对应的引用数量
2. 无法解决对象间循环引用的问题
