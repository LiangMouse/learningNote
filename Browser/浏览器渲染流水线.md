# 浏览器渲染

浏览器接收到服务端传来的 HTML、CSS 等资源后，是如何把它们转换成可视页面的？这一整套流程就称为浏览器的渲染流水线。

## 概览

- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算出 DOM 节点的样式。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 渲染流水线所分阶段

主要按时间顺序分为以下阶段：构建 DOM 树、样式计算、布局、分层、绘制、分块、光栅化与最终合成。

每个阶段都可以用一句话概括：明确输入、处理过程以及输出，即 output = func(input)。

### 构建 dom 树

- 输入：HTML。

- 输出：DOM 树。

- 为什么：浏览器无法直接使用 HTML，需要先解析成 DOM 树。

- DOM 树也就是 JS 中的 `Document Object Model`，可以通过 `window.document` 访问。

- 处理过程:

  <img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/img/dom-tree-process.png" alt="DOM树构建过程" style="zoom:50%;" />

**`window.document` 对象几乎是立即创建的，但它所代表的 DOM 树是在解析 HTML 的过程中一点点构建出来的。**

1. **创建 `document`**：浏览器请求 HTML 文件，一旦开始接收到数据，它就会**立即创建 `window` 对象和 `document` 对象**。在这一刻，`document` 对象是存在的，但它里面几乎是空的（DOM 树还没有内容）。
2. **解析和构建（Parsing）**：浏览器开始**从上到下**逐行阅读你的 HTML 代码。
   - 读到 `<html>`，它创建 `html` 节点。
   - 读到 `<head>`，它创建 `head` 节点，并将其附加到 `html` 节点上。
   - ...
3. **JS 的“介入”时机（关键点）**：
   - 假设你的 `<script>` 标签放在 `<head>` 里面（并且没有 `defer` 属性）：
   - 浏览器解析到 `<script>` 标签时，它会**暂停构建 DOM 树**，立即下载并执行这个 JS 脚本。
   - 在你的 JS 脚本中，`window.document` **是可以访问的**（因为它在第 1 步就被创建了）。
   - **但是**，如果你试图访问 `document.body` 或者 HTML 中靠后的一个 `div`（比如 `document.getElementById('my-div')`），你会得到 `null` （注意不是 undefined）。**因为此时浏览器还没有解析到 `<body>` 或那个 `div`**，它们在 DOM 树中还不存在。
4. **构建完成**：浏览器解析完所有 HTML，整个 DOM 树就完整了

### 样式计算

- 输入：DOM 树。

- 输出：每个 DOM 节点都附带样式信息的 DOM 树，以及 `window.styleSheets`。

- 处理过程:

  - CSS 的三个来源
    1. link 标签的外部 CSS 资源
    2. html 文件内的 style 标签
    3. html 元素的内联 style 属性
  - 一、类似 HTML，浏览器也无法直接处理 CSS 内容，需要先转换成 styleSheets。

  <img src="/Users/liangshuang/note/系统学习/浏览器工作原理与实践/assets/image-20251102213922185.png" alt="image-20251102213922185" style="zoom:50%;" />

  - 这个样式表是前述三种 CSS 来源合并后的结果，渲染引擎会把获取到的 CSS 文本全部转换成 styleSheets 结构，同时具备查询与修改能力。
  - 二、对 CSS 属性值进行**标准化**，例如把 `red` 转成 `rgb(255,0,0)`，把 `bold` 转成 `700`，把 `em` 转成对应的 `px`。
  - 三、计算出每个 DOM 节点上的具体样式。
    - 这涉及 CSS 的继承与层叠规则：
      - CSS 继承指 DOM 子节点可以继承父节点样式。
      - <img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/img/inherit-source.png" alt="继承来源" style="zoom:50%;" />
      - 样式层叠：是一个**定义了如何合并来自多个源的属性值的算法**。
      - ...
    - 最终，渲染引擎遵循继承与层叠规则，计算出每个 DOM 节点上的具体样式。可以在浏览器开发者工具 Elements 面板的 Computed 视图看到这些计算结果。

> 此时，浏览器的 HTML Parser 和 Css Parser 分别把 HTML 转换成 **DOM 数据结构**，把 CSS 转换成 **CSSOM 数据结构**。
>
> 然后，它把 **DOM** 和 **CSSOM** 这两个**数据结构**暴露给 **JavaScript 引擎**。

### 布局阶段

- 输入：带有样式信息的 DOM 树。
- 输出：包含可见元素几何信息的布局树。该阶段需要完成两个任务——创建布局树和执行布局计算。
- 计算过程：
  - 创建布局树
    - 遍历 DOM 树中所有**可见**元素并加入布局树。不可见元素会被跳过，例如 `<head>` 内的内容。
  - 布局计算
    - 计算布局树中每个节点的坐标与尺寸，并将结果写回布局树。

### 分层

- 输入：布局树。
- 输出：多颗图层树。
- 做了什么：在绘制前，需要对 3D 变换、Z 轴排序等内容做分层处理，渲染引擎会输出多个图层树，最终共同组成页面。
  - 布局树中的每个节点都直接或间接地映射到某棵图层树。
  - 满足什么条件才会创建新图层？
    - 拥有层叠上下文属性的元素
      - html 元素本身（第一个根层叠上下文)
      - Position 属性值非 static 并且 z-index 不是 auto
    - 出现了裁剪 clip 情况 (实际内容大小超出了给定的盒子大小)，图层就会被提升至一层

### 图层绘制

- 输入：图层树。

- 输出：包含多个绘制指令的绘制列表（此阶段仍在浏览器主线程中执行，尚未真正绘制）。

- 本质上是把一个图层的绘制拆分成很多小指令，并按顺序组成待绘制列表。

  ​ 具体步骤可以看浏览器开发者工具的 layers 标签

  <img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/img/draw-list.png" alt="绘制列表" style="zoom:50%;" />

  区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。

### 栅格化操作

- 输入：绘制列表。

- 输出：多个图块以及对应的位图，存储于 GPU 中。

- 步骤：

  - 实际绘制操作由渲染进程的合成线程来完成

  ![渲染进程](https://github.com/w-l-l/BrowserPrinciple/raw/main/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/img/render-process.png)

  合成线程会把图层划分为图块，即优先渲染视口附近的部分来生成位图。栅格化负责把图块转换成位图，通常由 GPU 来完成，生成的位图也存储在 GPU 内存中。

  <img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9AHTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/img/gpu-create-bitmap.png" alt="GPU生成位图" style="zoom:50%;" />

  ## 合成和显示

输入：所有图块生成的位图。

输出：浏览器显示出的最终页面。

过程：

一旦所有图块被光栅化，合成线程就会生成绘制图块的命令——`DrawQuad`，并提交给浏览器进程。

浏览器进程中的 `viz` 组件负责接收合成线程发送的 `DrawQuad` 命令，将页面内容绘制到内存中，最后显示到屏幕上。
