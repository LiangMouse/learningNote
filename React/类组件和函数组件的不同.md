# 类组件和函数组件的不同
是的，在 React 函数组件中无法直接使用类组件的生命周期钩子（如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 等），但可以通过 **Hooks** 实现类似的生命周期功能。

---

### 常用 Hooks 替代生命周期钩子的方式

1. **`useEffect`**
    - 负责处理**副作用**（如数据获取、订阅、DOM 操作）。
    - 根据依赖数组的变化，可以模拟不同的生命周期钩子。

#### `componentDidMount` 替代（只在组件挂载时执行）

```javascript
import React, { useEffect } from 'react';

function MyComponent() {
    useEffect(() => {
        console.log('Component mounted');
    }, []); // 空数组表示仅在初次渲染时执行
    return <div>Hello World</div>;
}
```

#### `componentDidUpdate` 替代（依赖变化时执行）

```javascript
import React, { useEffect, useState } from 'react';

function MyComponent() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        console.log(`Count updated to ${count}`);
    }, [count]); // 仅在 count 改变时执行

    return (
        <button onClick={() => setCount(count + 1)}>Increment</button>
    );
}
```

#### `componentWillUnmount` 替代（清理工作）

```javascript
import React, { useEffect } from 'react';

function MyComponent() {
    useEffect(() => {
        console.log('Component mounted');

        return () => {
            console.log('Component unmounted');
        };
    }, []); // 空数组，确保清理函数在组件卸载时执行

    return <div>Hello World</div>;
}
```

---

2. **`useState`**
    - 用于管理函数组件中的状态。

```javascript
import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}
```

---

3. **`useRef`**
    - 替代 `componentDidMount` 或 `componentDidUpdate` 中需要访问 DOM 或持久变量的场景。

```javascript
import React, { useRef, useEffect } from 'react';

function MyComponent() {
    const inputRef = useRef();

    useEffect(() => {
        inputRef.current.focus(); // 组件挂载后自动聚焦
    }, []);

    return <input ref={inputRef} />;
}
```

---

4. **`useMemo` 和 `useCallback`**
    - 替代类组件中的性能优化（类似 `shouldComponentUpdate`）。

#### 使用 `useMemo` 缓存计算结果

```javascript
import React, { useMemo } from 'react';

function ExpensiveCalculation({ num }) {
    const result = useMemo(() => {
        console.log('Calculating...');
        return num * 2; // 假设这是耗时操作
    }, [num]);

    return <div>Result: {result}</div>;
}
```

#### 使用 `useCallback` 缓存函数引用

```javascript
import React, { useCallback } from 'react';

function MyComponent({ onClick }) {
    const handleClick = useCallback(() => {
        console.log('Button clicked');
    }, []); // 空依赖数组表示函数不会重新创建

    return <button onClick={handleClick}>Click me</button>;
}
```

---

### 总结

函数组件没有原生的生命周期钩子，但可以通过以下 Hooks 实现类似功能：

|类组件生命周期|函数组件替代 Hook|
|---|---|
|`componentDidMount`|`useEffect(() => {}, [])`|
|`componentDidUpdate`|`useEffect(() => {}, [dependency])`|
|`componentWillUnmount`|`useEffect(() => { return () => {} }, [])`|
|`shouldComponentUpdate`|`useMemo` 或 `useCallback`|

这些 Hooks 提供了更细粒度的控制，同时也适合函数式编程的范式，使得代码更易读、更模块化。
![[Pasted image 20241122143506.png]]
![[Pasted image 20241122143507.png]]![[Pasted image 20241122143520.png]]
// 1.script start

// 2.Promise

// 3.script end

// 4.async2 end

// 5.async1 end

// 6.promise1

// 7.promise2

// 8.setTimeout