# 单例模式

## 含义

遵循单例模式的类，在当前应用中只能存在一个实例，并对外提供全局唯一访问点（通常是静态方法或模块导出）。

常见价值：

- 共享状态：避免同一资源的多处重复创建（如配置、连接、缓存）。
- 统一协调：作为全局中枢（事件总线、日志中心、指标上报）。
- 资源受控：统一生命周期与释放时机。

## 应用场景

### EsModule 模块

单文件，一个文件就是一个模块，同时也可以看成一个单例对象。

使用的时候`import`就可以，即使是有多个文件对他 import，这两个引入的对象仍旧是同一个对象

注意：ESM 的“单例”是基于同一运行时与同一路径解析缓存的模块实例缓存，对于多进程/多 Worker 并不天然跨边界共享。

### UI

- 遮罩层
- Toaster 组件，也就是悬浮在动作之后绿色的表示进行成功的通知条~

更多例子：

- 配置中心/环境变量读取器；
- 日志记录器（Logger）；
- 全局状态容器（非框架内置场景）；
- 连接池/网络客户端（需谨慎并发与重连策略）。

## 实现方式（JavaScript/TypeScript）

### 1）ESM 天然单例

```ts
// config.ts（被多处引用仍只有一个实例）
export const config = { apiBaseUrl: "/api", featureFlags: {} };
```

### 2）闭包 + 惰性初始化

```ts
// singleton.ts
type Instance = { count: number; inc(): void };

let instance: Instance | null = null;

export function getInstance(): Instance {
  if (instance) return instance;
  instance = {
    count: 0,
    inc() {
      this.count += 1;
    },
  };
  return instance;
}
```

### 3）类的静态方法/私有构造

```ts
class Store {
  private static _instance: Store | null = null;
  private constructor(private _state: Record<string, unknown> = {}) {}

  static getInstance(): Store {
    if (!Store._instance) {
      Store._instance = new Store();
    }
    return Store._instance;
  }

  get(key: string) {
    return this._state[key];
  }
  set(key: string, value: unknown) {
    this._state[key] = value;
  }
}

export default Store;

// 使用
// const store = Store.getInstance();
```

### 4）依赖注入容器中的单例

在 IoC/DI 框架（如 InversifyJS）中，可通过作用域声明为 `Singleton`，由容器管理实例唯一性与生命周期。

## 优缺点与注意事项

- 优点：简单直接、全局共享、减少重复创建开销；
- 缺点：隐藏全局可变状态，增加耦合与测试难度，不利于并发隔离；
- 注意：
  - 浏览器多 Tab/多进程、Node 多进程/Worker 并不共享单例实例；
  - SSR/多请求并发需避免将请求态数据放入进程级单例（会串数据）；
  - 测试中应提供重置/替身（mock）能力，避免状态残留

## 与模块化/工程的关系

- 规范参考：`JavaScript/模块化.md`
- 工程实践：在打包与懒加载场景，关注单例被多副本打包的问题，合理 external 与分包，避免跨 chunk 引入导致重复实例化（取决于构建策略与运行时）。
