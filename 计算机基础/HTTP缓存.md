# HTTP 缓存

对于重复幂等性的 HTTP 请求，通常使用**缓存**来提升性能分为强缓存和协商缓存两种

缓存存到浏览器此磁盘的缓存空间中，并非 LocalStorage/SessionStorage 等

## 强缓存

### 基础知识

- 含义: 只要在设定的未过期时间内，就直接取浏览器本地存储读取响应信息
- 出现标志: 仍然返回`200`状态码， 浏览器自身模拟请求全流程，但是会在 200 之后跟一个 **(from disk cache)** 来标示强缓存
- 是否发生强缓存: HTTP 响应头字段信息
  - `Cache control` : 相对时间
  - `Expires` : 绝对时间
  - 建议使用前者，且前者优先级更高，并且需要注意当前时间戳大于上次服务器与相对时间和时，防止缓存策略改变会重新更新`Cache control`

## 协商缓存

- 含义： 第二次及之后请求同一处资源时通过计算判断是否远程与本地有更新，若两者一致则返回 304 并使用本地资源
- 出现表示: 会发起网络请求，并收到 **304**状态码
- 实现方式:
  - 请求头中字段`If-Modified-Since`, 响应头字段`Last-Modified`

## 使用场景对比

| 特性             | **强缓存 (Strong Caching / Freshness)**                                                                                             | **协商缓存 (Conditional Caching / Validation)**                                                                                                                                              |
| :--------------- | :---------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **判断依据**     | 浏览器本地判断，不发送 HTTP 请求到服务器。                                                                                          | 浏览器发送 HTTP 请求到服务器，由服务器决定是否使用缓存。                                                                                                                                     |
| **对应 Header**  | `Cache-Control` (优先级更高) 和 `Expires`                                                                                           | 浏览器发送：`If-None-Match` 或 `If-Modified-Since` <br>服务器响应：`ETag` 或 `Last-Modified`                                                                                                 |
| **主要优点**     | 速度极快，完全没有网络开销。                                                                                                        | 避免重复传输相同的文件数据，节省带宽。                                                                                                                                                       |
| **最佳应用场景** | **资源内容不常变动** 或 **对实时性要求不高** 的文件，以及可以承受一定延迟更新的场景。                                               | **资源内容可能会变动**，但变动频率较低，且需要确保用户拿到最新版本或高效校验的场景。                                                                                                         |
| **具体使用场景** | - **JS/CSS 等静态资源**：文件名带有 **Hash 值/版本号**（实现“永不过期”）。<br> - **Logo、图标等不更新的图片**：设置较长的过期时间。 | - **HTML 文件**：需要每次校验以确保结构更新。<br> - **数据接口 (API)**：需要快速验证数据是否有更新，尤其是使用 `ETag` 校验。 <br> - **文件内容可能更新的图片**：如用户头像等。               |
| **缓存流程**     | 浏览器检查本地缓存 $\to$ 未过期 $\to$ **直接使用缓存**。                                                                            | 浏览器检查本地缓存 $\to$ 已过期 $\to$ **发送请求带校验信息** $\to$ 服务器校验：<br> - **未变** $\to$ 返回 `304 Not Modified`，使用缓存。<br> - **已变** $\to$ 返回 `200 OK` 及新的资源内容。 |

### 缓存策略的最终原则：

在实际应用中，最佳实践是 **结合使用** 强缓存和协商缓存：

1.  **首选强缓存**：对于大部分静态资源，应尽可能使用强缓存（设置较长的 `max-age`），以追求最佳性能。
2.  **强制更新**：对于需要强制更新的资源（如新的 CSS 或 JS 文件），通过 **修改文件名中的 Hash 或版本号** 来跳过强缓存。
3.  **退回协商缓存**：当强缓存失效或资源无法使用版本号管理时，**自动退回** 使用协商缓存进行高效校验。
