# OAuth

## 一、作用、组成

### 1.1 **倘若没有 Oauth**

如果一个应用，他需要读取其他应用的信息。没有 Oauth 前，我们需要手动提供给他账号密码供他访问。这显然是很危险的行为，自然地获得账密的应用会得到另一个应用所有权限，除非他不能工作你必须得无条件信任他

`Oauth`的出现，就是**为了创造一种“代客泊车钥匙” (Valet Key)：** 当你去酒店停车，给服务员的是一把**只能**用来开车门和点火的钥匙（Token），这把钥匙**打不开后备箱**（保护隐私），且**随时可以作废**，而原本的**主钥匙**（密码）始终在你手里。

### 1.2 Oauth 的**核心组成**

举例一个具体的场景: **我要用微信账号来登录 QQ 音乐**

| **角色名称 **  | **英文术语**             | **角色定义**                                       | **在场景中的身份**    |
| -------------- | ------------------------ | -------------------------------------------------- | --------------------- |
| **资源拥有者** | **Resource Owner**       | 能够授予访问权限的人（通常就是**用户**）。         | **你**                |
| **客户端**     | **Client**               | 想要访问用户数据的**第三方应用**                   | **QQ 音乐**           |
| **授权服务器** | **Authorization Server** | 负责验证用户身份并颁发“令牌”的服务器。它是守门员。 | **微信的登录服务器**  |
| **资源服务器** | **Resource Server**      | 存放用户数据（如头像、昵称、好友列表）的服务器。   | **微信的 API 服务器** |

Oauth 的核心过程就是通过**授权服务器给到客户端拿到令牌**， 而这个令牌就是所谓的`Access Token`。

### 1.3 `OAuth`的定义:

**OAuth 2.0 是一个关于“授权 (Authorization)”的行业标准协议。**

它提供了一种安全的机制，允许**用户**（资源拥有者）让**第三方应用**（客户端）获得对该用户在**某一服务**（资源服务器）上存储的**受保护资源**的**有限访问权限**，而**无需**将用户名和密码提供给第三方应用。

在实现上，他是将‘认证’与‘授权’解耦，利用 `Access Token`实现资源安全共享的协议框架。

## 二、授权码模式

### 2.1 是什么

授权码模式是最主流的用户第三方登录场景所使用的技术。简单说就是一个用户先获得授权服务器提供的`Code`， 然后在后端静默获得`Access Token`的流程。

**为什么不直接 Token，而是需要中间的 Code?**

`Token`就像一张**真正的电影票**。谁捡到了，谁就能进场看电影。

`Code`就像你在美团上买到的**取票码**。

- 你把取票码写在手背上走在大街上（Code 会暴露在浏览器 URL 中），别人看到了也没用。
- 因为要兑换电影票，不仅需要**取票码 (Code)**，还需要在电影院的自助机上输入**手机后四位 (Client Secret)**。

Code 是临时的、可暴露的；Token 是长期的、保密的。中间多这一步，就是为了把 Token 藏在后端，不经过浏览器。

### 2.2 **流程**

1. 前端发起请求，进行重定向（用户点击“使用 github 登录”，网站带一些参数重定向到 github 特定界面）

   ```http
   GET https://github.com/login/oauth/authorize?
     response_type=code       <-- 告诉 GitHub：我要“取票码”，先别给我Token
     &client_id=MY_APP_ID     <-- 我是 MyData 网站
     &redirect_uri=https://mydata.com/callback  <-- 完事了把人送回这儿
     &scope=read:user         <-- 我只想读用户信息，不干坏事
   ```

2. 用户在 Github 的页面上通过鉴权后进行确认，同意登录

3. github 回调到原网站并给到 Code。 生成一个临时的 Code，并重定向到

   ```md
   Location: https://mydata.com/callback?code=abc123456
   ```

4. 后端靠`Code`（”公钥“）和`CLient Secret`（只有双方知道）向授权服务器 github 发起请求

   ```HTTP
   POST /login/oauth/access_token HTTP/1.1
   Host: github.com
   Accept: application/json
   Content-Type: application/json

   {
     "client_id": "YOUR_APP_ID",           // 你的应用身份证
     "client_secret": "YOUR_APP_SECRET",   // 你的应用密钥（绝密！）
     "code": "abc123456",                  // 刚才拿到的临时授权码
     "grant_type": "authorization_code",   // 告诉 GitHub：我是来换票的
     "redirect_uri": "https://mydata.com/callback" // 安全校验，必须和第一步一模一样，避免是中间人攻击
   }
   ```

5. 授权服务器验证无误后，颁发`Token`

   ```JSON
   {
     "access_token": "e72e16c7e42f292c6912e7710c838347ae178b4a",
     "scope": "read:user",
     "token_type": "bearer"
   }
   ```

6. 拿到这个 `access_token` 后，你的后端通常会做两件事：

   1. **拿着它**去 GitHub 获取用户信息（比如用户名、头像）。

   2. **建立自己的会话**（比如生成一个你自己网站的 Session 或 JWT），让用户在你的系统里算作“已登录”。

## 三、常见问题

### 3.1 没有后端保存 client_secret —— PKAE

想象一个场景，如果开发了一个纯前端 `SPA` 应用或者是`Android/Ios`应用。这些应用的代码运行在用户的设备上，这就会导致前边授权码模式的`client_secret`容易造成泄漏 —— 解决这个问题，就得用到授权码模式的加强版，`PKAE`（Proof Key for Code Exchange）

**流程**

1. **生成暗号 (Code Verifier)**：
   - 前端应用在发起登录前，随机生成一串乱码字符串 `A`。
2. **加密暗号 (Code Challenge)**：
   - 前端对 `A` 进行哈希加密（SHA256），得到结果 `B`。
3. **发起请求**：
   - 前端告诉 GitHub：“我要登录，请记住这个哈希值 `B`。”（**只发加密后的 B，不发 A**）。
4. **换取 Token**：
   - 前端拿到 `Code` 后，去换 Token 时，**不再发送 `client_secret`**，而是发送原始的乱码字符串 `A`。
5. **服务器验证**：
   - GitHub 收到 `A`，自己用同样的算法加密一下，看看是不是等于刚才存下的 `B`。如果不等，说明有人中途截获了 Code 企图冒充。

PKCE 模式本质上还是**授权码模式**，只是把“静态的 Client Secret”换成了“动态生成的 Verifier/Challenge”。**这是目前所有前端应用（SPA/Mobile）对接 OAuth 的标准做法。**

### 3.2 服务器间的 OAuth 通信 —— 客户端凭证模式

**场景**：你的后端服务需要每天凌晨去阿里云的对象存储（OSS）清理日志文件。这个操作**没有用户参与**，是你自己的服务器在和阿里云的服务器对话。

**问题**：没有“用户”点击同意，怎么授权？

**方法**

使用客户端凭证模式。因为是你自己的服务器，你完全信任它，所以直接用 ID 和 Secret 换 Token。

**特点：**

- 没有重定向，没有浏览器，没有用户同意页面。
- 拿到的 Token 通常代表“应用本身”的权限，而不是“某个用户”的权限。

### 3.3 Access Token 有效时间短，如何延长用户登录时间又不需要重新登录 —— 双 token

授权码模式获得的`Access Token` 为了安全，有效期通常很短（比如 1 小时）。但是用户肯定不希望在一个网站上过个一小时就要重新登录一下这样糟糕的体验。

我们通过引入`refresh token`来解决。在上边授权码模式中“换取 Token”那一步，服务器通常会返回**两个**令牌：

1. **Access Token** (短命，1 小时)：用来请求数据，比如传给 API。
2. **Refresh Token** (长命，30 天)：用来**换取新的 Access Token**。

**流程**

1. 前端用 Access Token 请求 API。
2. API 返回 `401 Unauthorized` (Token 过期)。
3. 前端（通常在拦截器里）悄悄拿着 Refresh Token 去找授权服务器：“老哥，过期了，换个新的。”
4. 服务器验证 Refresh Token 没过期，**颁发一个新的 Access Token** (可能还会给一个新的 Refresh Token)。
5. 前端拿到新 Token，重试刚才失败的 API 请求。
6. **用户对此毫无感知**，体验非常丝滑。

## 四、Token

`Access Token`主要分为两种

### 4.1 不透明令牌

传统的最早期做法，作为没有任何意义的随机字符存在，形如`gho_16C7e42F292c6912E771`

**行为**

- **客户端**（前端）：看不懂，只管存。
- **资源服务器**（API）：也看不懂。收到 Token 后，必须**回头去问**授权服务器：“大哥，这串字符是谁？有效吗？能干嘛？”

**优缺点**

- **优点**：**极度安全，随时可撤销**。授权服务器只要在数据库里把这行删了，Token 瞬间失效。
- **缺点**：**慢**。每次 API 调用都要去查数据库或调授权服务的接口，不仅有网络延迟，还会给数据库造成巨大压力。

### 4.2 JWT

当前的主流`Token`格式

**内容**

一长串用`.`分割的字符。特点是自带信息，可以理解成一张经过数字签名的身份证。由**过期时间、用户 ID、权限范围**组成。

- **Header (头部)**：告诉服务器用什么算法加密的（如 `HS256`）。

- **Payload (载荷)**：存放实际数据。**注意！这里面的数据只是 Base64 编码，并不是加密的！** 任何人拿到 Token 都能看到里面的内容。

  - 千万不要在 JWT 里放密码或敏感信息！

- **Signature (签名)**：防篡改的封条。如果有人改了 Payload 里的权限，签名就会对不上。

**优缺点**

- **优点**：**快，无状态**。资源服务器拿到 JWT，只需要用**公钥**验一下签名（看看是不是伪造的），如果签名对，就直接放行，**不需要**去查数据库，也不用问授权服务器。

- **缺点**：**难撤销**。一旦发出去，只要没过期，谁拿来都能用。你没法在服务器端“强制让它失效”（除非搞黑名单机制，但这又变复杂了）。

### 4.3 权限

`token`由`Code`生成，Code 中又有`scope`参数，这就会让 Token 中自带权限限制

## 五、安全

### 5.1 前端在哪存 Token

- 如果存在`LocalStorage/ sessionStorage`中
  - 优点：使用方便
  - 缺点（致命）：非常容易被`XSS`攻击，只需要恶意脚本运行`localStorage.getItem('token')`就可以拿到
- 存在`Cookie`中
  - 优点：可以设置`HTTPOnly`属性避免被`XSS`脚本攻击；每次请求自动携带
  - 缺点： 有被`CRSF`攻击的风险（由于同源策略，风险较 XSS 低）；`Cookie`内存小，相较下，token 内存占用很大

我认为比较好的实践是存在设置了`HttpOnly` + `Secure` + `SameSite=Strict` 的 Cookie 中

### 5.2 防 csrf 攻击的 state 参数

**如果没有 state**

1. **黑客的操作**：
   - 黑客在自己的电脑上，点击“使用 GitHub 登录”。
   - GitHub 给他生成了一个 `Code = 黑客的Code`。
   - 黑客**立刻停止**跳转，不让自己的电脑用这个 Code。
2. **设置陷阱**：
   - 黑客构造一个链接：`http://mydata.com/callback?code=黑客的Code`。
   - 黑客发邮件骗你：“点击领取 100 元红包！”
3. **你的中招**：
   - 你点击了链接。
   - 你的浏览器带着 `黑客的Code` 访问了 `MyData` 网站。
   - `MyData` 网站分不清这是谁发起的，一看有 Code，就去 GitHub 换了 Token。
   - **结果**：你的浏览器里的 Cookie 显示“登录成功”，但登录的是**黑客的账号**。你接下来的一切操作，都是在帮黑客“练级”。

**作用**

`state`在其中起到的作用就是自己的`auth-url`只能自己去认证和回调

再次回到上边的例子中

1. 当你要点击“GitHub 登录”时，你的 `MyData` 前端（或后端）生成一个**随机乱码**（比如 `xyz123`）。
2. 把它存到你浏览器的 **Cookie** 里（标记为“我发出的暗号”）。
3. 把它作为 `state` 参数传给 GitHub： `https://github.com/login...?state=xyz123`

4. GitHub 不管这参数啥意思，它只是办事。办完事后，它会把这个参数**原封不动**地带回来。
5. （攻击的关键防御点）\*\* 你的浏览器重定向回 `http://mydata.com/callback?code=...&state=xyz123`。

​ 你的后端（或前端）立刻做一件事：**比对！**

1. 取出 URL 里的 `state` (来自 GitHub) = `xyz123`
2. 取出 Cookie 里的 `state` (你出发前存的) = `xyz123`
3. **相等吗？**
   1. 相等**：说明这个请求确实是**你刚才**发起的。-> **放行，换 Token**。**
   2. 不相等**（或者 Cookie 里根本没有）：说明这是**天上掉下来的 Code**（可能是黑客发给你的链接）。-> **报错。攻击被拦截。

### 5.3 redirect_uri 白名单防劫持

授权码获取过程中，必传参数`redirect_uri`是在登录认证服务商认证后重定向的链接，这个参数指定的 uri 必须要在服务商内定的白名单中。想象中间人黑客劫持了认证的网络请求，将重定向的`uri`改为了黑客自己私有网站，但是这被服务商后台识别到不可信，直接进行请求报错。拦截劫持
