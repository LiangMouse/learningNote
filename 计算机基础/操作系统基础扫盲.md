# 操作系统基础

由于前端特别是校招不会太重点问操作系统，暂时只针对重点问题进行收集进行分享

## 进程、线程、协程

### 进程（Process）

**定义** ：进程是操作系统分配资源的基本单位，是一个正在运行的程序实例。它包括代码、数据、堆栈、文件描述符等资源。
**特点**：

- 每个进程有独立的内存地址空间（虚拟内存），进程间隔离性强（一个进程崩溃不会直接影响其他进程）。
- 创建和销毁开销大，因为需要分配/释放大量资源（如内存、I/O）。
- 进程间通信（IPC）较复杂，通常通过管道、消息队列或共享内存实现。
- 适合处理需要高隔离的任务，如运行多个独立应用，浏览器中的不同 Tab
- 进程是“重量级”的，操作系统调度它。

### 线程（Thread）

**定义** ：线程是进程内的执行单元，是操作系统调度的最小单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。
**特点**：

- 线程间共享内存（全局变量、堆），但每个线程有自己的栈和寄存器（用于保存局部变量和执行上下文）。
- 创建和切换开销小（比进程轻量），但仍需操作系统内核介入（上下文切换有开销）。
- 线程间通信简单（直接共享内存），但容易出现竞态条件（race condition），需要锁或同步机制。
- 适合多核 CPU 并行执行计算密集型任务。
- 线程是“中量级”的，允许多个执行流并发运行。

### 协程（Coroutine）

**定义** ：协程是一种用户态（程序员控制）的轻量级线程，不依赖操作系统内核调度。它通过协作式调度（cooperative scheduling）运行，即协程主动让出控制权（yield）给其他协程。
**特点**：

- 协程共享线程的内存，开销极小（创建/切换只需用户空间操作，无内核切换）。
- 执行是协作式的：协程不会被抢占，只有在 yield 点（如 await）才切换，减少了锁的需求，避免线程的上下文切换开销。
- 适合 I/O 密集型任务（如网络请求），因为它可以高效处理异步操作，而不阻塞线程。
- 如果是计算密集型，会阻塞整个线程（因为协作式）。
- 协程是“轻量级”的，常用于异步编程框架中，如 Go 的 goroutine 或 NodeJS 的 async/await。

## 进程的内存管理

## 死锁

死锁（Deadlock）是指在多线程或多进程并发执行时，多个线程或进程因为相互等待对方持有的资源，导致彼此都无法继续执行下去的一种僵局。出现死锁后，相关的程序会一直卡住，严重时可能影响整个系统的正常运行。

死锁的产生通常需要同时满足以下四个必要条件（也称为死锁的四个必要条件）：

1. **互斥条件**：某些资源一次只能被一个进程占用（即资源不能被共享）。
2. **不可剥夺条件**：进程已经获得的资源，在未使用完之前，不能被强行剥夺，只能由进程自己释放。
3. **请求与保持条件**：进程在持有至少一个资源的情况下，又提出新的资源请求，而该资源被其他进程占用，此时进程阻塞，但对已获得的资源保持不放。
4. **循环等待条件**：存在一种进程资源的循环等待关系，即进程 A 等待被进程 B 占用的资源，进程 B 又等待进程 C 的资源，……，最后某个进程又等待进程 A 的资源，形成一个环路。

只有这四个条件同时成立时，才可能发生死锁。实际开发中，理解并避免死锁是并发编程的重要内容之一。

## 虚拟内存
