# 操作系统基础

由于前端特别是校招不会太重点问操作系统，暂时只针对重点问题进行收集进行分享

## 进程、线程、协程

### 进程（Process）
**定义** ：进程是操作系统分配资源的基本单位，是一个正在运行的程序实例。它包括代码、数据、堆栈、文件描述符等资源。
**特点**：
- 每个进程有独立的内存地址空间（虚拟内存），进程间隔离性强（一个进程崩溃不会直接影响其他进程）。
- 创建和销毁开销大，因为需要分配/释放大量资源（如内存、I/O）。
- 进程间通信（IPC）较复杂，通常通过管道、消息队列或共享内存实现。
- 适合处理需要高隔离的任务，如运行多个独立应用，浏览器中的不同Tab
- 进程是“重量级”的，操作系统调度它。

### 线程（Thread）

**定义** ：线程是进程内的执行单元，是操作系统调度的最小单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。
**特点**：
- 线程间共享内存（全局变量、堆），但每个线程有自己的栈和寄存器（用于保存局部变量和执行上下文）。
- 创建和切换开销小（比进程轻量），但仍需操作系统内核介入（上下文切换有开销）。
- 线程间通信简单（直接共享内存），但容易出现竞态条件（race condition），需要锁或同步机制。
- 适合多核CPU并行执行计算密集型任务。
- 线程是“中量级”的，允许多个执行流并发运行。

### 协程（Coroutine）
**定义** ：协程是一种用户态（程序员控制）的轻量级线程，不依赖操作系统内核调度。它通过协作式调度（cooperative scheduling）运行，即协程主动让出控制权（yield）给其他协程。
**特点**：
- 协程共享线程的内存，开销极小（创建/切换只需用户空间操作，无内核切换）。
- 执行是协作式的：协程不会被抢占，只有在yield点（如await）才切换，减少了锁的需求，避免线程的上下文切换开销。
- 适合I/O密集型任务（如网络请求），因为它可以高效处理异步操作，而不阻塞线程。
- 如果是计算密集型，会阻塞整个线程（因为协作式）。
- 协程是“轻量级”的，常用于异步编程框架中，如Go的goroutine或NodeJS的async/await。 


## 进程的内存管理

## 死锁

死锁 是指在多线程或多进程并发操作中，多个线程或进程因相互等待资源而陷入无法继续执行的状态。这种情况会导致系统的部分或全部功能无法正常运行。

## 虚拟内存
