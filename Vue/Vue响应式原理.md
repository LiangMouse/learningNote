# Vue 响应式原理

Vue 响应式原理是实现数据驱动视图的核心机制，即当数据发生变化时，视图会自动更新。因为从 Vue2 到 Vue3 的迭代中，整个响应式原理有很大的变化，下边分开来说，两者的原理以及区别都是面试中常考的内容

## 一、Vue2 的响应式原理

Vue2 的响应式基于**`Object.defineProperty()`** 实现，核心逻辑是：  
对数据对象的**每个属性**进行遍历，通过`Object.defineProperty()`为属性添加`getter`（获取属性时触发，也就是依赖收集）和`setter`（修改属性时触发，也就是派发更新）。

- 当属性被访问（如在模板中使用），`getter`会将当前组件的依赖（Watcher）收集到“依赖管理器 `dep`”中；
- 当属性被修改，`setter`会通知依赖管理器，触发所有相关依赖（组件）重新渲染。

但`Object.defineProperty`的`setter`只能监听到值的内容,存在无法感知对象属性增删等操作。Vue2 不得不采取不那么优雅的方式，重写 Vue 作用域中的数组方法，如`push`、`pop`、`splice`等，以触发依赖更新。 见[源码](https://github.com/vuejs/vue/blob/v2.6.14/src/core/observer/array.js)

## 二、Vue3 的响应式原理

Vue3 的响应式基于**`Proxy`** 实现，核心逻辑是：  
通过`Proxy`创建数据对象的“代理对象”，直接拦截对**整个对象**的操作（如属性访问、修改、新增、删除等），并配合`Reflect`（反射）完成原始操作的执行。这也是 Vue3 即使是对基本数据类型作`ref`响应式包裹，也得用`.value`才能访问的原因。

- 当对代理对象进行任何操作（如`obj.foo`访问、`obj.foo = 1`修改、`delete obj.foo`删除、`obj.newKey = 2`新增），`Proxy`的拦截器（如`get`、`set`、`deleteProperty`）会触发；
- 拦截时会收集依赖或触发更新，实现数据与视图的联动。

## 三、核心区别

| 维度              | Vue2（Object.defineProperty）                                                                                                                      | Vue3（Proxy）                                                         |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| 监听对象粒度      | 监听**对象的单个属性**，需要遍历对象所有属性初始化响应式                                                                                           | 监听**整个对象**，无需遍历属性，直接代理对象本身                      |
| 新增/删除属性支持 | 不支持。新增属性（如`obj.newKey = 1`）或删除属性（如`delete obj.key`）不会触发更新，需通过`this.$set`/`this.$delete`手动处理                       | 原生支持。直接新增/删除属性会被`Proxy`拦截，自动触发更新              |
| 数组监听方式      | 需重写数组的 7 个方法（`push`/`pop`/`splice`等），通过包装方法触发更新；无法监听通过索引修改数组（如`arr[0] = 1`）或修改长度（如`arr.length = 0`） | 无需重写数组方法。`Proxy`可直接拦截数组的索引修改、长度修改等所有操作 |
| 深层嵌套对象处理  | 初始化时递归遍历所有深层属性，立即转为响应式（无论是否使用）                                                                                       | 懒加载处理：仅当访问深层属性时，才递归为其创建代理（按需处理）        |
| 数据类型支持      | 仅支持对象和数组，对`Map`/`Set`等复杂类型支持有限                                                                                                  | 原生支持`Object`/`Array`/`Map`/`Set`等所有内置对象类型                |

## 四、Vue3 响应式升级带来的好处

1. **更全面的响应式覆盖**  
   无需依赖`$set`/`$delete`，新增/删除属性、通过索引修改数组等操作可直接触发更新，开发更自然。

2. **更好的性能**

   - 懒加载处理深层对象：避免初始化时递归所有属性（尤其数据量大时），减少初始性能消耗；
   - 直接代理对象而非遍历属性：初始化速度更快，内存占用更低。

3. **更完善的类型支持**  
   对`Map`/`Set`等复杂数据类型的原生支持，满足更多业务场景（如需要频繁添加/删除键值对的场景）。

4. **更简洁的代码逻辑**  
   无需重写数组方法，响应式实现代码更简洁，维护成本更低。
