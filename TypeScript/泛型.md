# TypeScript 泛型

TypeScript 泛型（Generics）是一种强大的类型系统特性，允许在定义函数、类或接口时不预先指定具体的类型，而是在使用时再指定类型参数。这类似于函数传参，使类型约束更加灵活和可复用。

## 泛型的优势

- **类型安全**：在编译时提供类型检查，减少运行时错误
- **代码复用**：同一套逻辑可适用于多种类型，避免重复代码
- **可读性强**：通过类型参数明确表达代码意图
- **智能提示**：IDE 能够提供更准确的代码补全和错误提示

## 基本语法

### 泛型函数

```typescript
// 基本泛型函数
function identity<T>(arg: T): T {
  return arg;
}

// 使用方式
const num = identity<number>(123);    // 显式指定类型
const str = identity("hello");        // 类型推断为 string

// 多个泛型参数
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const result = pair<string, number>("age", 25); // [string, number]
```

### 泛型接口

```typescript
interface Container<T> {
  value: T;
  getValue(): T;
  setValue(value: T): void;
}

interface ApiResponse<T> {
  code: number;
  data: T;
  message: string;
  timestamp: number;
}

// 使用泛型接口
const userResponse: ApiResponse<{ id: number; name: string }> = {
  code: 200,
  data: { id: 1, name: "Alice" },
  message: "success",
  timestamp: Date.now()
};
```

### 泛型类型别名

```typescript
type Result<T, E = Error> = {
  success: true;
  data: T;
} | {
  success: false;
  error: E;
};

// 使用示例
const successResult: Result<string> = {
  success: true,
  data: "操作成功"
};

const errorResult: Result<never, string> = {
  success: false,
  error: "网络错误"
};
```

## 实际应用

### 泛型类

```typescript
class HZFEMember<T, U> {
  private id!: T;
  private name!: U;

  setMember(id: T, name: U): void {
    this.id = id;
    this.name = name;
  }

  getMember(): { id: T; name: U } {
    return { id: this.id, name: this.name };
  }

  show(): void {
    console.log(`ID: ${this.id}, Name: ${this.name}`);
  }
}

const member1 = new HZFEMember<number, string>();
member1.setMember(1, "QingZhen");
member1.show(); // ID: 1, Name: QingZhen

const member2 = new HZFEMember<string, string>();
member2.setMember("02", "Aki");
member2.show(); // ID: 02, Name: Aki
```

### 泛型数组操作

```typescript
// 根据长度和单个数据生成数组
function createArray<T>(length: number, item: T): T[] {
  return Array(length).fill(item);
}

const numbers = createArray<number>(3, 0);     // [0, 0, 0]
const strings = createArray<string>(2, "hi");  // ["hi", "hi"]

// 数组过滤器
function filterArray<T>(array: T[], predicate: (item: T) => boolean): T[] {
  return array.filter(predicate);
}

const evenNumbers = filterArray([1, 2, 3, 4, 5], n => n % 2 === 0); // [2, 4]
```

## 内置泛型工具类型

### Record

`Record<K, T>` 构造一个对象类型，其属性键为 K，属性值为 T。

```typescript
type UserRole = "admin" | "user" | "guest";
type UserInfo = { name: string; permissions: string[] };

const roleConfig: Record<UserRole, UserInfo> = {
  admin: { name: "管理员", permissions: ["read", "write", "delete"] },
  user: { name: "普通用户", permissions: ["read", "write"] },
  guest: { name: "访客", permissions: ["read"] }
};

// 动态键值对
type HttpStatusCode = Record<number, string>;
const statusMessages: HttpStatusCode = {
  200: "OK",
  404: "Not Found",
  500: "Internal Server Error"
};
```

### Partial、Required、Readonly

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  age?: number;
}

// Partial - 所有属性变为可选
type PartialUser = Partial<User>;
// { id?: number; name?: string; email?: string; age?: number }

// Required - 所有属性变为必需
type RequiredUser = Required<User>;
// { id: number; name: string; email: string; age: number }

// Readonly - 所有属性变为只读
type ReadonlyUser = Readonly<User>;
// { readonly id: number; readonly name: string; ... }
```

### Pick、Omit

```typescript
interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  category: string;
}

// Pick - 选择特定属性
type ProductSummary = Pick<Product, "id" | "name" | "price">;
// { id: number; name: string; price: number }

// Omit - 排除特定属性
type ProductWithoutId = Omit<Product, "id">;
// { name: string; price: number; description: string; category: string }
```

## 泛型约束

### extends 约束

```typescript
// 约束泛型必须有 length 属性
function getLength<T extends { length: number }>(arg: T): number {
  return arg.length;
}

getLength("hello");        // ✅ 5
getLength([1, 2, 3]);      // ✅ 3
getLength({ length: 10 }); // ✅ 10
// getLength(123);         // ❌ 错误：number 没有 length 属性

// 约束泛型为对象的键
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30, city: "Beijing" };
const name = getProperty(person, "name");  // string
const age = getProperty(person, "age");    // number
// const invalid = getProperty(person, "salary"); // ❌ 错误
```

### 条件类型

```typescript
// 条件类型示例
type IsArray<T> = T extends any[] ? true : false;

type Test1 = IsArray<string[]>;  // true
type Test2 = IsArray<number>;    // false

// 实用的条件类型
type NonNullable<T> = T extends null | undefined ? never : T;

type SafeString = NonNullable<string | null>; // string
```

## 高级用法

### 映射类型

```typescript
// 为对象的所有属性添加可选标记
type Optional<T> = {
  [K in keyof T]?: T[K];
};

// 为对象的所有属性添加 null 类型
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

interface Config {
  apiUrl: string;
  timeout: number;
  retries: number;
}

type OptionalConfig = Optional<Config>;
// { apiUrl?: string; timeout?: number; retries?: number }

type NullableConfig = Nullable<Config>;
// { apiUrl: string | null; timeout: number | null; retries: number | null }
```

### 默认泛型参数

```typescript
// 带默认类型的泛型
interface ApiClient<T = any, E = Error> {
  request<R = T>(url: string): Promise<R>;
  handleError(error: E): void;
}

// 泛型函数的默认参数
function createState<T = string>(initialValue: T): {
  get(): T;
  set(value: T): void;
} {
  let state = initialValue;
  return {
    get: () => state,
    set: (value: T) => { state = value; }
  };
}

const stringState = createState("hello");     // T 默认为 string
const numberState = createState<number>(42);  // 显式指定 T 为 number
```

## 实战示例

### 通用数据获取器

```typescript
class DataFetcher<T> {
  private cache = new Map<string, T>();

  async fetch(url: string, parser: (data: any) => T): Promise<T> {
    if (this.cache.has(url)) {
      return this.cache.get(url)!;
    }

    const response = await fetch(url);
    const rawData = await response.json();
    const parsedData = parser(rawData);

    this.cache.set(url, parsedData);
    return parsedData;
  }

  clearCache(): void {
    this.cache.clear();
  }
}

// 使用示例
interface User {
  id: number;
  name: string;
  email: string;
}

const userFetcher = new DataFetcher<User>();
const user = await userFetcher.fetch('/api/user/1', (data) => ({
  id: data.id,
  name: data.name,
  email: data.email
}));
```

### 事件系统

```typescript
type EventMap = {
  click: { x: number; y: number };
  keypress: { key: string; ctrlKey: boolean };
  resize: { width: number; height: number };
};

class EventEmitter<T extends Record<string, any> = EventMap> {
  private listeners = new Map<keyof T, Array<(data: T[keyof T]) => void>>();

  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(listener);
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(listener => listener(data));
    }
  }
}

// 使用示例
const emitter = new EventEmitter<EventMap>();

emitter.on('click', ({ x, y }) => {
  console.log(`点击位置: (${x}, ${y})`);
});

emitter.emit('click', { x: 100, y: 200 });
```

## 最佳实践

1. **命名约定**：使用有意义的泛型参数名
   ```typescript
   // ❌ 不好
   function process<T, U, V>(a: T, b: U): V { ... }

   // ✅ 更好
   function transform<Input, Output, Config>(
     data: Input,
     config: Config
   ): Output { ... }
   ```

2. **适度使用约束**：为泛型添加合理的约束
   ```typescript
   // 确保类型安全
   function sortBy<T extends Record<string, any>, K extends keyof T>(
     array: T[],
     key: K
   ): T[] {
     return array.sort((a, b) => a[key] - b[key]);
   }
   ```

3. **提供默认类型**：为常用场景提供默认类型
   ```typescript
   interface HttpClient<T = any> {
     get(url: string): Promise<T>;
     post(url: string, data: any): Promise<T>;
   }
   ```

## 参考链接

- [TypeScript Handbook - Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- [Advanced Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)

